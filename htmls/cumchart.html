<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tehran Stock History</title>
    <link rel="stylesheet" href="styles.css">
    <!-- Chart.js Library -->
    <script src="chart.js"></script>
    <!-- Chart.js Date Adapter -->
    <script src="chartjs-adapter-date-fns.bundle.min.js">
    </script>
    <script type="module" src="optimizedGaussianSmoother.js"></script>

</head>

<body>
    <div class="container">
        <div class="input-controls">
            <label for="windowSizeInput">Window Size:</label>
            <input type="number" id="windowSizeInput" value="10" />
            <label for="sigmaInput">Sigma:</label>
            <input type="number" id="sigmaInput" value="10" />
            <button id="applyButton">Apply</button>
        </div>

        <div class="combined-chart-wrapper">
            <!-- Checkbox Container -->
            <div class="checkbox-container" id="symbolCheckboxes">
                <!-- Checkboxes will be dynamically added here -->
            </div>
            <div class="chart-area">
                <canvas id="combinedNormalizedChart"></canvas>
            </div>
            <div class="slider-container">
                <input type="range" class="date-range-slider" id="dateSlider">
                <div class="date-labels">
                    <div id="startDateLabel">Start Date</div>
                    <div id="currentDateLabel">Current Date</div>
                    <div id="endDateLabel">End Date</div>
                </div>
            </div>
        </div>
        <div id="chartsContainer">
            <!-- Individual charts will be dynamically added here -->
        </div>
        <div id="loadingIndicator" class="loading" style="display: none;">
            <div class="loading-spinner"></div>
            <div>Loading data...</div>
        </div>
    </div>

    <script type="module">
        import { smoothGaussian } from './optimizedGaussianSmoother.js';

        let combinedDatasets = []; // Stores all dataset info (original/smoothed data)
        let combinedChart = null; // Reference to the combined chart instance

        let currentWindowSize = 5;
        let currentSigma = 1.0;

        // Define symbols and their corresponding colors
        const symbolsAndColors = [
            // --- Core Indicators (Contrasting) ---
            { symbol: "shakhes", color: 'rgb(255, 59, 48)', smoothable: false },   // Red
            { symbol: "dollar", color: 'rgb(52, 199, 89)', smoothable: false },    // Green
            { symbol: "shakhes_dollar_ratio", color: 'rgb(88, 86, 214)', smoothable: false }, // Indigo

            // --- Base Symbols (Unique Hues) ---
            { symbol: "saham_majmu", color: 'rgb(0, 122, 255)', smoothable: false },   // Blue (Stocks)
            { symbol: "saham", color: 'rgb(10, 132, 255)', smoothable: false },       // Lighter Blue (Stocks)
            { symbol: "s_saham", color: 'rgb(40, 142, 255)', smoothable: false },     // Lightest Blue (Stocks)
            { symbol: "ahrom", color: 'rgb(255, 149, 0)', smoothable: false },       // Orange (Leverage)
            { symbol: "s_tala", color: 'rgb(255, 204, 0)', smoothable: false },       // Gold/Yellow (Gold)
            { symbol: "s_sabet", color: 'rgb(48, 209, 88)', smoothable: false },      // Teal (Fixed Income)
            { symbol: "s_zamin", color: 'rgb(162, 132, 94)', smoothable: false },     // Brown (Land/Real Estate)
            { symbol: "s_amlak", color: 'rgb(172, 142, 104)', smoothable: false },    // Light Brown (Property)
            { symbol: "e_forush", color: 'rgb(255, 45, 85)', smoothable: false },     // Magenta (Sellable ETF)
            { symbol: "ati_ahrom", color: 'rgb(255, 169, 30)', smoothable: false },    // Light Orange (Leverage)
            { symbol: "s_dar_s", color: 'rgb(175, 82, 222)', smoothable: false },     // Purple (Mixed Asset)
            { symbol: "sokuk", color: 'rgb(142, 142, 147)', smoothable: false },     // Gray (Bonds)
            { symbol: "e_kharid", color: 'rgb(90, 200, 250)', smoothable: false },    // Cyan (Purchasable ETF)
            { symbol: "s_kala_ghaza", color: 'rgb(200, 180, 50)', smoothable: false }, // Olive (Commodity)

            // --- 'g' Prefixes (Darker versions of base colors) ---
            { symbol: "gsaham_majmu", color: 'rgb(0, 85, 179)', smoothable: false },
            { symbol: "gsaham", color: 'rgb(7, 92, 179)', smoothable: false },
            { symbol: "gs_saham", color: 'rgb(28, 99, 179)', smoothable: false },
            { symbol: "gahrom", color: 'rgb(179, 104, 0)', smoothable: false },
            { symbol: "gs_tala", color: 'rgb(179, 143, 0)', smoothable: false },
            { symbol: "gs_sabet", color: 'rgb(34, 146, 62)', smoothable: false },
            { symbol: "gs_zamin", color: 'rgb(113, 92, 66)', smoothable: false },
            { symbol: "gs_amlak", color: 'rgb(120, 99, 73)', smoothable: false },
            { symbol: "ge_forush", color: 'rgb(179, 32, 59)', smoothable: false },
            { symbol: "gati_ahrom", color: 'rgb(179, 118, 21)', smoothable: false },
            { symbol: "gs_dar_s", color: 'rgb(123, 57, 155)', smoothable: false },
            { symbol: "gsokuk", color: 'rgb(99, 99, 103)', smoothable: false },
            { symbol: "ge_kharid", color: 'rgb(63, 140, 175)', smoothable: false },
            { symbol: "gs_kala_ghaza", color: 'rgb(140, 126, 35)', smoothable: false },

            // --- 'v' Prefixes (Lighter versions of base colors) ---
            { symbol: "vsaham_majmu", color: 'rgb(102, 179, 255)', smoothable: true },
            { symbol: "vsaham", color: 'rgb(108, 182, 255)', smoothable: true },
            { symbol: "vs_saham", color: 'rgb(124, 189, 255)', smoothable: true },
            { symbol: "vahrom", color: 'rgb(255, 191, 102)', smoothable: true },
            { symbol: "vs_tala", color: 'rgb(255, 224, 102)', smoothable: true },
            { symbol: "vs_sabet", color: 'rgb(136, 229, 162)', smoothable: true },
            { symbol: "vs_zamin", color: 'rgb(199, 182, 164)', smoothable: true },
            { symbol: "vs_amlak", color: 'rgb(208, 189, 168)', smoothable: true },
            { symbol: "ve_forush", color: 'rgb(255, 135, 160)', smoothable: true },
            { symbol: "vati_ahrom", color: 'rgb(255, 204, 120)', smoothable: true },
            { symbol: "vs_dar_s", color: 'rgb(209, 159, 238)', smoothable: true },
            { symbol: "vsokuk", color: 'rgb(190, 190, 193)', smoothable: true },
            { symbol: "ve_kharid", color: 'rgb(163, 224, 252)', smoothable: true },
            { symbol: "vs_kala_ghaza", color: 'rgb(222, 210, 138)', smoothable: true },

            // --- Other Real Estate (in the Brown family) ---
            { symbol: "apartment", color: 'rgb(140, 110, 70)', smoothable: false }, // Darker Brown
            { symbol: "plotold", color: 'rgb(180, 150, 110)', smoothable: false }   // Mid-tone Brown
        ];
        // Define colors for easy access
        const colors = symbolsAndColors.map(item => item.color);

        // Base Chart.js options
        const baseChartOptions = {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    type: 'time',
                    time: {
                        parser: 'yyyy-MM-dd',
                        tooltipFormat: 'yyyy-MM-dd'
                    },
                    title: {
                        display: true,
                        text: 'Date'
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'Value'
                    }
                }
            },
            plugins: {
                legend: {
                    display: false, // Hide the default legend
                },
                tooltip: {
                    mode: 'index',
                    intersect: false
                },
                crosshair: {
                    color: 'rgba(255, 0, 0, 0.8)', // Customize crosshair color
                    lineWidth: 1.5 // Customize crosshair line width
                }
            }
        };

        /**
         * Crosshair Plugin Definition
         */
        const crosshairPlugin = {
            id: 'crosshair',
            afterInit: function (chart, args, options) {
                chart.crosshair = {
                    x: null,
                    y: null
                };

                const canvas = chart.canvas;

                // Mouse move handler
                const mouseMoveHandler = (event) => {
                    const rect = canvas.getBoundingClientRect();
                    const x = event.clientX - rect.left;
                    const y = event.clientY - rect.top;
                    chart.crosshair.x = x;
                    chart.crosshair.y = y;
                    chart.draw();
                };

                // Mouse out handler
                const mouseOutHandler = () => {
                    chart.crosshair.x = null;
                    chart.crosshair.y = null;
                    chart.draw();
                };

                canvas.addEventListener('mousemove', mouseMoveHandler);
                canvas.addEventListener('mouseout', mouseOutHandler);

                // Store handlers to remove them later if needed
                chart._crosshairHandlers = { mouseMoveHandler, mouseOutHandler };
            },
            afterDraw: function (chart, args, options) {
                if (chart.crosshair.x !== null && chart.crosshair.y !== null) {
                    const ctx = chart.ctx;
                    const x = chart.crosshair.x;
                    const y = chart.crosshair.y;
                    const chartArea = chart.chartArea;

                    ctx.save();
                    ctx.strokeStyle = options.color || 'rgba(0,0,0,0.8)';
                    ctx.lineWidth = options.lineWidth || 1;

                    // Draw vertical line
                    ctx.beginPath();
                    ctx.moveTo(x, chartArea.top);
                    ctx.lineTo(x, chartArea.bottom);
                    ctx.stroke();

                    // Draw horizontal line
                    ctx.beginPath();
                    ctx.moveTo(chartArea.left, y);
                    ctx.lineTo(chartArea.right, y);
                    ctx.stroke();

                    ctx.restore();
                }
            },
            beforeDestroy: function (chart) {
                const handlers = chart._crosshairHandlers;
                if (handlers) {
                    chart.canvas.removeEventListener('mousemove', handlers.mouseMoveHandler);
                    chart.canvas.removeEventListener('mouseout', handlers.mouseOutHandler);
                }
            }
        };

        function configureChartOptionsForMobile() {
            // Check if the viewport width matches mobile screen size
            if (window.matchMedia("(max-width: 768px)").matches) {
                Chart.defaults.font.size = 10;
                Chart.defaults.plugins.legend.labels.boxWidth = 10;
                Chart.defaults.plugins.legend.labels.padding = 5;
            }
        }

        function registerChartPlugins() {
            // Register the Crosshair Plugin globally
            Chart.register(crosshairPlugin);
        }

        // Separate click handler function for the Apply button
        async function handleApplyClick() {
            const windowSize = parseInt(document.getElementById('windowSizeInput').value, 10);
            const sigma = parseFloat(document.getElementById('sigmaInput').value);

            if (!windowSize || windowSize < 1 || !sigma || sigma <= 0) {
                alert("Invalid parameters");
                return;
            }

            showLoading();

            try {
                combinedDatasets.forEach(dataset => {
                    if (dataset.smoothable) {
                        const yValues = dataset.originalData.map(d => d.y);
                        const smoothedY = smoothGaussian(yValues, windowSize, sigma);
                        dataset.data = dataset.originalData.map((d, i) => ({
                            x: d.x,
                            y: smoothedY[i]
                        }));
                    }
                });

                // Re-normalize all datasets
                const slider = document.getElementById('dateSlider');
                const selectedDate = new Date(parseInt(slider.value));
                const endDate = combinedChart.initialEndDate;

                combinedChart.data.datasets.forEach((chartDataset, index) => {
                    const sourceData = combinedDatasets[index].data;
                    chartDataset.data = normalizeDataWithinRange(sourceData, selectedDate, endDate);
                });

                combinedChart.update();
            } catch (error) {
                console.error("Smoothing error:", error);
                alert("Failed to apply smoothing. Check parameters.");
            } finally {
                hideLoading();
            }
        }

        /**
         * Normalize data within a given date range
         * @param {Array} data - Array of data points
         * @param {Date} startDate - Start date for normalization
         * @param {Date} endDate - End date for normalization
         * @returns {Array} - Normalized data points
         */
        function normalizeDataWithinRange(data, startDate, endDate) {
            const filteredData = data.filter(point => {
                const date = new Date(point.x);
                return date >= startDate && date <= endDate;
            });

            if (filteredData.length === 0) {
                return [];
            }

            const yValues = filteredData.map(point => point.y);
            const min = Math.min(...yValues);
            const max = Math.max(...yValues);
            const range = max - min;

            return filteredData.map(point => ({
                x: point.x,
                y: range === 0 ? 0 : ((point.y - min) / range) * 2 - 1,
            }));
        }

        /**
         * Create the combined normalized chart with checkboxes
         * @param {HTMLElement} wrapper - The wrapper element for the chart
         * @param {Array} datasets - Array of dataset objects
         * @returns {Chart} - The created Chart.js instance
         */
        function createCombinedChartWithCheckboxes(wrapper, datasets) {
            const canvas = document.getElementById('combinedNormalizedChart');
            const ctx = canvas.getContext('2d');

            // Get all unique dates
            const allDates = new Set();
            datasets.forEach(dataset => dataset.data.forEach(point => allDates.add(new Date(point.x).getTime())));
            const sortedDates = Array.from(allDates).sort((a, b) => a - b);

            if (sortedDates.length === 0) {
                console.error('No data available to display the chart.');
                return;
            }

            // Calculate initial dates FIRST
            const initialStartDate = new Date(sortedDates[0]);
            const initialEndDate = new Date(sortedDates[sortedDates.length - 1]);

            // Create chart FIRST
            const chart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: datasets.map((dataset, index) => ({
                        label: dataset.symbol,
                        data: normalizeDataWithinRange(dataset.data, initialStartDate, initialEndDate),
                        borderColor: colors[index],
                        tension: 0.1,
                        hidden: false
                    })),
                },
                options: {
                    ...baseChartOptions,
                    plugins: {
                        ...baseChartOptions.plugins,
                        title: {
                            display: true,
                            text: 'Combined Normalized Chart (Dynamic Normalization)'
                        }
                    }
                }
            });

            // Add date properties AFTER chart creation
            chart.initialStartDate = initialStartDate;
            chart.initialEndDate = initialEndDate;

            // Initialize slider
            const slider = document.getElementById('dateSlider');
            slider.min = sortedDates[0];
            slider.max = sortedDates[sortedDates.length - 1];
            slider.step = 24 * 60 * 60 * 1000;
            slider.value = sortedDates[0];

            // Set up date labels
            document.getElementById('startDateLabel').textContent = initialStartDate.toISOString().split('T')[0];
            document.getElementById('endDateLabel').textContent = initialEndDate.toISOString().split('T')[0];
            document.getElementById('currentDateLabel').textContent = initialStartDate.toISOString().split('T')[0];

            // Slider event handler
            slider.addEventListener('input', function (e) {
                const selectedDate = new Date(parseInt(e.target.value));
                document.getElementById('currentDateLabel').textContent = selectedDate.toISOString().split('T')[0];

                chart.data.datasets.forEach((dataset, index) => {
                    dataset.data = normalizeDataWithinRange(
                        datasets[index].data,
                        selectedDate,
                        chart.initialEndDate
                    );
                });
                chart.update();
            });

            // Create checkboxes
            const checkboxContainer = document.getElementById('symbolCheckboxes');
            symbolsAndColors.forEach((item, index) => {
                const checkboxItem = document.createElement('div');
                checkboxItem.className = 'checkbox-item';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `checkbox_${item.symbol}`;
                checkbox.checked = ['saham', 's_tala', 's_sabet', 'apartment'].includes(item.symbol);
                checkbox.dataset.index = index;

                const label = document.createElement('label');
                label.htmlFor = `checkbox_${item.symbol}`;
                label.textContent = item.symbol;
                label.style.color = item.color;

                // Set initial visibility
                chart.data.datasets[index].hidden = !checkbox.checked;

                checkbox.addEventListener('change', () => {
                    chart.data.datasets[index].hidden = !checkbox.checked;
                    chart.update();
                });

                checkboxItem.appendChild(checkbox);
                checkboxItem.appendChild(label);
                checkboxContainer.appendChild(checkboxItem);
            });

            return chart;
        }

        /**
         * Create the combined normalized chart
         * @param {Object} data - The fetched data
         */
        function createCombinedNormalizedChart(data) {
            combinedDatasets = [];

            for (const item of symbolsAndColors) {
                const dataset = createDataset(data, item.symbol);
                if (!dataset) continue;

                let processedData = dataset.data;
                if (item.smoothable) {
                    const yValues = dataset.data.map(d => d.y);
                    // Initial window size and sigma both 10
                    const smoothedY = smoothGaussian(yValues, 10, 10);
                    processedData = dataset.data.map((d, i) => ({
                        x: d.x,
                        y: smoothedY[i]
                    }));
                }

                combinedDatasets.push({
                    symbol: item.symbol,
                    originalData: dataset.data,
                    data: processedData,
                    smoothable: item.smoothable
                });
            }

            combinedChart = createCombinedChartWithCheckboxes(
                document.querySelector('.combined-chart-wrapper'),
                combinedDatasets
            );
        }
        /**
         * Show loading indicator
         */
        function showLoading() {
            document.getElementById('loadingIndicator').style.display = 'block';
        }

        /**
         * Hide loading indicator
         */
        function hideLoading() {
            document.getElementById('loadingIndicator').style.display = 'none';
        }

        /**
         * Format date from integer to 'yyyy-MM-dd'
         * @param {number} dateInt - Date as integer in 'yyyyMMdd' format
         * @returns {string} - Formatted date string
         */
        function formatDate(dateInt) {
            const dateStr = dateInt.toString();
            return `${dateStr.substring(0, 4)}-${dateStr.substring(4, 6)}-${dateStr.substring(6, 8)}`;
        }

        /**
         * Create dataset for a given symbol
         * @param {Object} rawData - The raw fetched data
         * @param {string} symbol - The symbol name
         * @returns {Object|null} - The dataset object or null if symbol not found
         */
        function createDataset(rawData, symbol) {
            if (!rawData[symbol]) return null;

            return {
                data: rawData[symbol].map(point => ({
                    x: formatDate(point.dt),
                    y: point.cs
                }))
            };
        }

        /**
         * Create an individual chart
         * @param {HTMLElement} wrapper - The wrapper element for the chart
         * @param {Object} dataset - The dataset object
         * @param {string} symbol - The symbol name
         * @param {string} color - The color for the chart
         */
        function createChart(wrapper, dataset, symbol, color) {
            // Create chart container
            const container = document.createElement('div');
            container.className = 'chart-container';
            const canvas = document.createElement('canvas');
            canvas.id = `chart_${symbol}`;
            container.appendChild(canvas);

            // Create slider container
            const sliderContainer = document.createElement('div');
            sliderContainer.className = 'slider-container';
            const slider = document.createElement('input');
            slider.type = 'range';
            slider.className = 'date-range-slider';
            slider.min = 0;
            slider.max = dataset.data.length - 1;
            slider.value = 0;
            sliderContainer.appendChild(slider);

            // Create date labels
            const dateLabels = document.createElement('div');
            dateLabels.className = 'date-labels';
            const startDateLabel = document.createElement('div');
            startDateLabel.textContent = dataset.data.length > 0 ? dataset.data[0].x : 'Start Date';
            const currentDateLabel = document.createElement('div');
            currentDateLabel.textContent = dataset.data.length > 0 ? dataset.data[0].x : 'Current Date';
            const endDateLabel = document.createElement('div');
            endDateLabel.textContent = dataset.data.length > 0 ? dataset.data[dataset.data.length - 1].x : 'End Date';

            dateLabels.appendChild(startDateLabel);
            dateLabels.appendChild(currentDateLabel);
            dateLabels.appendChild(endDateLabel);

            sliderContainer.appendChild(dateLabels);

            wrapper.appendChild(container);
            wrapper.appendChild(sliderContainer);

            const ctx = canvas.getContext('2d');

            // Clone base options and customize
            const options = JSON.parse(JSON.stringify(baseChartOptions));
            options.plugins.title = {
                display: true,
                text: `${symbol} - Original Values`
            };

            // Format Y-axis ticks to scientific notation
            options.scales.y.ticks = {
                callback: function (value) {
                    return value.toExponential();
                }
            };

            const chart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: symbol,
                        data: dataset.data,
                        borderColor: color,
                        tension: 0.1,
                        hidden: false
                    }]
                },
                options: options
            });

            // Handle slider input
            slider.addEventListener('input', function (e) {
                const startIndex = parseInt(e.target.value);
                const slicedData = dataset.data.slice(startIndex);
                currentDateLabel.textContent = slicedData.length > 0 ? slicedData[0].x : 'No Data';

                chart.data.datasets[0].data = slicedData;
                chart.update();
            });
        }

        /**
         * Create all individual charts
         * @param {Object} data - The fetched data
         */
        function createCharts(data) {
            // Create the combined normalized chart
            createCombinedNormalizedChart(data);

            // Create individual charts
            const chartsContainer = document.getElementById('chartsContainer');
            chartsContainer.innerHTML = '';

            for (let item of symbolsAndColors) {
                const dataset = createDataset(data, item.symbol);
                if (!dataset) continue;

                const chartWrapper = document.createElement('div');
                chartWrapper.className = 'chart-wrapper';
                chartsContainer.appendChild(chartWrapper);

                createChart(chartWrapper, dataset, item.symbol, item.color);
            }
        }

        /**
         * Handle errors during data fetching
         * @param {Error} error - The error object
         */
        function handleError(error) {
            console.error('Error fetching data:', error);
            hideLoading();
            const container = document.querySelector('.container');
            const errorDiv = document.createElement('div');
            errorDiv.textContent = 'Error loading chart data. Please try again later.';
            errorDiv.style.color = 'red';
            errorDiv.style.textAlign = 'center';
            errorDiv.style.marginTop = '20px';
            container.appendChild(errorDiv);
        }

        /**
         * Fetch data from the server
         * @returns {Promise<Object>} - The fetched JSON data
         */
        async function fetchData() {
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000); // 30s timeout

                const response = await fetch('../getAllCumulatives', {
                    signal: controller.signal,
                    headers: {
                        'Accept': 'application/json'
                    }
                });

                clearTimeout(timeoutId);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                if (error.name === 'AbortError') {
                    throw new Error('Request timeout');
                }
                throw error;
            }
        }

        /**
         * Initialize the application
         */
        async function main() {
            console.log('Main function started');
            showLoading();

            try {
                const data = await fetchData();
                if (data) {
                    createCharts(data);
                }
                hideLoading();
            } catch (error) {
                handleError(error);
            }
        }

        configureChartOptionsForMobile();
        registerChartPlugins();

        // Start the application on window load
        window.addEventListener('load', main);
        document.getElementById('applyButton').addEventListener('click', handleApplyClick);
        document.getElementById('windowSizeInput').addEventListener('change', function () {
            // Automatically update sigma when window size changes
            document.getElementById('sigmaInput').value = this.value;
        });
    </script>
</body>

</html>